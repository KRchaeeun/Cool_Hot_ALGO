import sys
sys.stdin = open("input.txt")

# 이진 탐색을 활용하여 블루레이의 최소 크기를 찾는 문제
# 주어진 강의들을 M개의 블루레이에 분배해야 하는데, 블루레이 하나에 녹화할 수 있는 최대 길이를 최소화하는 것이 목표

# 각 강의를 순차적으로 블루레이에 녹화하면서, 블루레이의 크기를 조절해 나가는 방식으로 해결
# 이진 탐색을 통해 가능한 블루레이의 최소 크기를 효율적으로 찾고
# 각 단계에서 블루레이의 크기를 기준으로 현재 블루레이에 강의를 더 녹화할 수 있는지 판단하고,
# 녹화할 수 없을 경우 새로운 블루레이로 교체하며 진행
# 따라서 필요한 블루레이의 총 수를 구하고, 이를 이진 탐색의 기준으로 사용

# 이분탐색을 사용하는 이유: 가능한 한 적은 수의 블루레이로 모든 강의를 녹화하면서, 각 블루레이의 크기를 최소로 해야한다
# 이분탐색은 이런 최적화 문제에서 범위 내에서 특정 조건을 만족하는 최적의 값(최소의 블로레이 크기)를 효율적으로 찾을 때 유용
# 1. 강의 길이의 합계는 크고 정렬이 되어있는 상태
# 2. 블루레이 크기가 증가하면 녹화할 수 있는 강의 수도 증가
# 3. 모든 강의를 확인 하려면 시간 복잡도가 너무 큼. 이분 탐색이면 logN이므로 효율적

# 입력: 강의 수 n, 블루레이 수 m, 각 강의의 길이가 담긴 리스트 blueray
n, m = map(int, input().split())
blueray = list(map(int, input().split()))

# 이진 탐색을 위한 시작점(가장 긴 강의 길이)과 끝점(모든 강의의 총 길이)
left, right = max(blueray), sum(blueray)

# 이진 탐색 시작
while left <= right:
    mid = (left + right) // 2  # 중간점 계산
    cnt = 0  # 블루레이 개수 카운트
    record = 0  # 현재 블루레이에 녹화된 강의의 총 길이

    # 각 강의를 순회하면서 블루레이에 녹화
    for i in range(n):
        # 현재 블루레이에 강의를 더 녹화할 수 없으면 새 블루레이로 교체
        if record + blueray[i] > mid:
            cnt += 1
            record = 0
        record += blueray[i]

    # 마지막 블루레이를 카운트에 추가
    if record:
        cnt += 1

    # 블루레이 개수가 m 이하면 크기를 줄임
    if cnt <= m:
        right = mid - 1
    # 블루레이 개수가 m을 초과하면 크기를 늘림
    else:
        left = mid + 1

# 최종 계산된 블루레이 최소 크기 출력
print(left)
